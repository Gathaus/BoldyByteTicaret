# Error Handling & Logging Rules

Bu projede hata yönetimi ve logging için kurallar.

## Exception Hierarchy

### Custom Exception Types
Proje için özel exception türleri tanımlanmalı:

```csharp
// ✅ Custom exception base class
public abstract class BusinessException : Exception
{
    protected BusinessException(string message) : base(message) { }
    protected BusinessException(string message, Exception innerException) : base(message, innerException) { }
}

// Specific business exceptions
public class ProductNotFoundException : BusinessException
{
    public ProductNotFoundException(int productId) 
        : base($"Product with ID {productId} was not found") { }
}

public class InsufficientStockException : BusinessException
{
    public InsufficientStockException(string productName, int availableStock, int requestedQuantity)
        : base($"Insufficient stock for product '{productName}'. Available: {availableStock}, Requested: {requestedQuantity}") { }
}

public class InvalidOrderStateException : BusinessException
{
    public InvalidOrderStateException(string currentState, string requestedAction)
        : base($"Cannot perform '{requestedAction}' on order in '{currentState}' state") { }
}
```

## Service Layer Error Handling

### Exception Throwing in Services
Service layer'da appropriate exception'lar fırlatılmalı:

```csharp
// ✅ Doğru service exception handling
public async Task<Product> GetProductByIdAsync(int id)
{
    if (id <= 0)
        throw new ArgumentException("Product ID must be greater than zero", nameof(id));
        
    var product = await _productRepository.GetByIdAsync(id);
    if (product == null)
        throw new ProductNotFoundException(id);
        
    return product;
}

public async Task<Order> CreateOrderAsync(CreateOrderDto dto)
{
    // Validate business rules
    foreach (var item in dto.Items)
    {
        var product = await _productRepository.GetByIdAsync(item.ProductId);
        if (product == null)
            throw new ProductNotFoundException(item.ProductId);
            
        if (product.Stock < item.Quantity)
            throw new InsufficientStockException(product.Name, product.Stock, item.Quantity);
    }
    
    try
    {
        // Create order logic
        return await _orderRepository.AddAsync(order);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error creating order for user {UserId}", dto.UserId);
        throw new ServiceException("Failed to create order", ex);
    }
}
```

## Controller Error Handling

### Exception to HTTP Status Code Mapping
Controller'larda exception'ları doğru HTTP status code'larına map edilmeli:

```csharp
// ✅ Doğru controller error handling
[HttpGet("{id}")]
public async Task<IActionResult> GetProduct(int id)
{
    try
    {
        var product = await _productService.GetProductByIdAsync(id);
        return Ok(product);
    }
    catch (ArgumentException ex)
    {
        _logger.LogWarning(ex, "Invalid product ID provided: {ProductId}", id);
        return BadRequest(ex.Message);
    }
    catch (ProductNotFoundException ex)
    {
        _logger.LogInformation(ex, "Product not found: {ProductId}", id);
        return NotFound(ex.Message);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Unexpected error getting product {ProductId}", id);
        return StatusCode(500, "An error occurred while processing your request");
    }
}

[HttpPost]
public async Task<IActionResult> CreateOrder(CreateOrderDto dto)
{
    try
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);
            
        var order = await _orderService.CreateOrderAsync(dto);
        return CreatedAtAction(nameof(GetOrder), new { id = order.Id }, order);
    }
    catch (ProductNotFoundException ex)
    {
        return BadRequest(ex.Message);
    }
    catch (InsufficientStockException ex)
    {
        return Conflict(ex.Message);
    }
    catch (BusinessException ex)
    {
        return BadRequest(ex.Message);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error creating order");
        return StatusCode(500, "Failed to create order");
    }
}
```

## Global Exception Handling

### Exception Middleware
Global exception handling için middleware kullanılmalı:

```csharp
// ✅ Global exception middleware
public class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionMiddleware> _logger;
    
    public GlobalExceptionMiddleware(RequestDelegate next, ILogger<GlobalExceptionMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }
    
    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            await HandleExceptionAsync(context, ex);
        }
    }
    
    private async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        var response = context.Response;
        response.ContentType = "application/json";
        
        var errorResponse = new ErrorResponse();
        
        switch (exception)
        {
            case ProductNotFoundException:
                response.StatusCode = (int)HttpStatusCode.NotFound;
                errorResponse.Message = exception.Message;
                break;
                
            case InsufficientStockException:
                response.StatusCode = (int)HttpStatusCode.Conflict;
                errorResponse.Message = exception.Message;
                break;
                
            case BusinessException:
                response.StatusCode = (int)HttpStatusCode.BadRequest;
                errorResponse.Message = exception.Message;
                break;
                
            case ArgumentException:
                response.StatusCode = (int)HttpStatusCode.BadRequest;
                errorResponse.Message = exception.Message;
                break;
                
            default:
                response.StatusCode = (int)HttpStatusCode.InternalServerError;
                errorResponse.Message = "An error occurred while processing your request";
                _logger.LogError(exception, "Unhandled exception occurred");
                break;
        }
        
        var jsonResponse = JsonSerializer.Serialize(errorResponse);
        await response.WriteAsync(jsonResponse);
    }
}

public class ErrorResponse
{
    public string Message { get; set; }
    public string Details { get; set; }
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
}
```

### Middleware Registration
```csharp
// Program.cs'da middleware registration
app.UseMiddleware<GlobalExceptionMiddleware>();
```

## Logging Best Practices

### Structured Logging
Structured logging kullanılmalı:

```csharp
// ✅ Doğru structured logging
public async Task<Product> CreateProductAsync(CreateProductDto dto)
{
    _logger.LogInformation("Creating product {ProductName} in category {CategoryId}", 
        dto.Name, dto.CategoryId);
        
    try
    {
        var product = await _productRepository.AddAsync(new Product 
        { 
            Name = dto.Name, 
            Price = dto.Price 
        });
        
        _logger.LogInformation("Successfully created product {ProductId} with name {ProductName}", 
            product.Id, product.Name);
            
        return product;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Failed to create product {ProductName} in category {CategoryId}", 
            dto.Name, dto.CategoryId);
        throw;
    }
}

// Performance logging
public async Task<IEnumerable<Product>> GetProductsAsync(int page, int pageSize)
{
    using var activity = _logger.BeginScope("GetProducts - Page {Page}, Size {PageSize}", page, pageSize);
    
    var stopwatch = Stopwatch.StartNew();
    
    try
    {
        var products = await _productRepository.GetPagedAsync(page, pageSize);
        
        stopwatch.Stop();
        _logger.LogInformation("Retrieved {ProductCount} products in {ElapsedMs}ms", 
            products.Count(), stopwatch.ElapsedMilliseconds);
            
        return products;
    }
    catch (Exception ex)
    {
        stopwatch.Stop();
        _logger.LogError(ex, "Failed to retrieve products after {ElapsedMs}ms", 
            stopwatch.ElapsedMilliseconds);
        throw;
    }
}
```

### Log Levels
Appropriate log level'ları kullanılmalı:

```csharp
// ✅ Doğru log level usage
_logger.LogTrace("Entering method {MethodName} with parameters {Parameters}", nameof(CreateProduct), dto);
_logger.LogDebug("Validating product data: {ProductData}", dto);
_logger.LogInformation("Product {ProductId} created successfully", productId);
_logger.LogWarning("Product {ProductId} stock is low: {Stock}", productId, stock);
_logger.LogError(ex, "Failed to create product {ProductName}", dto.Name);
_logger.LogCritical(ex, "Database connection failed");
```

## Validation Error Handling

### Model Validation
Model validation error'ları için standardized response:

```csharp
// ✅ Model validation error handling
[HttpPost]
public async Task<IActionResult> CreateProduct(CreateProductDto dto)
{
    if (!ModelState.IsValid)
    {
        var errors = ModelState
            .Where(x => x.Value.Errors.Count > 0)
            .ToDictionary(
                kvp => kvp.Key,
                kvp => kvp.Value.Errors.Select(e => e.ErrorMessage).ToArray()
            );
            
        return BadRequest(new ValidationErrorResponse
        {
            Message = "Validation failed",
            Errors = errors
        });
    }
    
    // Continue with business logic
}

public class ValidationErrorResponse
{
    public string Message { get; set; }
    public Dictionary<string, string[]> Errors { get; set; }
}
```

## Repository Error Handling

### Database Error Handling
Repository layer'da database error'ları handle edilmeli:

```csharp
// ✅ Repository error handling
public async Task<Product> AddAsync(Product product)
{
    try
    {
        _context.Products.Add(product);
        await _context.SaveChangesAsync();
        return product;
    }
    catch (DbUpdateException ex) when (ex.InnerException is SqlException sqlEx)
    {
        // Handle specific SQL errors
        switch (sqlEx.Number)
        {
            case 2627: // Unique constraint violation
                throw new DuplicateEntityException($"Product with SKU {product.SKU} already exists");
            case 547: // Foreign key constraint violation
                throw new InvalidReferenceException($"Invalid category ID: {product.CategoryId}");
            default:
                _logger.LogError(ex, "Database error adding product {ProductName}", product.Name);
                throw new DataAccessException("Failed to save product", ex);
        }
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Unexpected error adding product {ProductName}", product.Name);
        throw;
    }
}
```

## Error Response Standards

### Consistent Error Response Format
Tüm API endpoint'leri için consistent error response format:

```csharp
// ✅ Standard error response
public class ApiErrorResponse
{
    public string Message { get; set; }
    public string ErrorCode { get; set; }
    public Dictionary<string, object> Details { get; set; }
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    public string TraceId { get; set; }
}

// Usage example
return BadRequest(new ApiErrorResponse
{
    Message = "Insufficient stock",
    ErrorCode = "INSUFFICIENT_STOCK",
    Details = new Dictionary<string, object>
    {
        ["ProductId"] = productId,
        ["AvailableStock"] = availableStock,
        ["RequestedQuantity"] = requestedQuantity
    },
         TraceId = Activity.Current?.Id
 });
 ```
